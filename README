Программа представляет собой реализацию Pub-Sub паттерна
Теоретически, на месте класса PubSubServer может стоять любой брокер,
реализующий этот паттерн (Redis, RabbitMQ, Dapr...)

Модуль состоит из следующих классов:

1) PubSubServer
  Собственно брокер, синглтон, но в теории может масштабироваться для обслуживания собственного
  пула серверов и клиентов

  Subscribe подписывает получателя на какую-то тему через интерфейс ISubscriber
  Unsubscribe обратное действие - отписывает
  Publish публикует команду в брокер

2) Command описывает команду.
  topic_ название "топика" для подписчика
  replayTopic_ если нам нужен ответ
  commandId_ - уникальный идентификатор команды эта штука нам нужна, 
  чтобы в синхронном вызове дождаться именно этой команды

3) Client
  Класс-клиент, который чередует асинхронные и синхронные вызовы в собственном потоке

  ExecuteSync - функция синхронного вызова, с ожиданием ответа
  Асинхронный вызов осуществляется просто публикацией команды pubSubServer_->Publish(command);
  все команды публикуются с топиком PubSubServer::TOPIC_COMMAND

  у каждого клиента должен быть уникальный идентификатор, это важно, чтобы работала Pub-Sub модель

4) ISubscriber - интерфейс получателя

5) Server - по сути сервер, который держит в себе список "процессоров команд" и если нет достаточно
  доступного процессора - пытается создать новый, но не более чем ядер в системе

  Является так же подписчиком на топик PubSubServer::TOPIC_COMMAND и соответственно получателем команд.

6) CommandProcessor - собственно, процессор команд. Команды добавляются ему в очередь
  и обрабатываются в собственном потоке. Создается ответ с payload_ == "REPLAY", с задержкой 1мс
  для эмуляции нагрузки. commandId_ сопируется с исходной команды, для реализации синхронных вызовов.
  topic_ выставляется в replayTopic_ исходного события, чтобы ответ попал правильному получателю